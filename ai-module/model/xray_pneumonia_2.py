# -*- coding: utf-8 -*-
"""xray_pneumonia_2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fpCP-77K_AXbtHcP-iqDtUhWfFh5pWeD
"""

from google.colab import files
uploaded = files.upload()
print("Uploaded:", list(uploaded.keys()))

!pip -q install opencv-python-headless

import os
import numpy as np
import tensorflow as tf
import cv2

MODEL_PATH = list(uploaded.keys())[0]  # assumes you uploaded only 1 file
model = tf.keras.models.load_model(MODEL_PATH)
print("Loaded model:", MODEL_PATH)
model.summary()

img_up = files.upload()
IMG_PATH = list(img_up.keys())[0]
print("Uploaded X-ray:", IMG_PATH)

IMG_SIZE = 224  # change only if your training used a different size

def load_and_preprocess(path, img_size=224):
    img_bgr = cv2.imread(path)
    if img_bgr is None:
        raise FileNotFoundError("Cannot read image: " + path)

    img_bgr = cv2.resize(img_bgr, (img_size, img_size))
    img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)

    x = img_rgb.astype(np.float32) / 255.0   # must match training
    x = np.expand_dims(x, axis=0)            # (1, H, W, 3)
    return img_bgr, x

orig_bgr, x = load_and_preprocess(IMG_PATH, IMG_SIZE)
print("Input tensor shape:", x.shape)

prob = float(model.predict(x, verbose=0)[0][0])  # sigmoid output
pred = "PNEUMONIA" if prob >= 0.5 else "NORMAL"

print("Probability (PNEUMONIA):", prob)
print("Predicted:", pred)

LAST_CONV_LAYER = None
for layer in reversed(model.layers):
    if isinstance(layer, tf.keras.layers.Conv2D):
        LAST_CONV_LAYER = layer.name
        break

print("Last Conv2D layer:", LAST_CONV_LAYER)

def make_gradcam_heatmap(img_tensor, model, last_conv_layer_name):
    # Build a model that maps input -> (conv layer output, final prediction)
    grad_model = tf.keras.Model(
        inputs=model.inputs,
        outputs=[model.get_layer(last_conv_layer_name).output, model.output]
    )

    with tf.GradientTape() as tape:
        conv_outputs, predictions = grad_model(img_tensor)
        loss = predictions[:, 0]  # sigmoid output

    # Compute gradients of prediction wrt conv feature maps
    grads = tape.gradient(loss, conv_outputs)

    # Global average pooling of gradients
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))

    # Weight the feature maps
    conv_outputs = conv_outputs[0]  # (H, W, C)
    heatmap = tf.reduce_sum(conv_outputs * pooled_grads, axis=-1)

    # Normalize
    heatmap = tf.maximum(heatmap, 0)
    heatmap = heatmap / (tf.reduce_max(heatmap) + 1e-8)

    return heatmap.numpy()

!pip -q install tf-explain

import tensorflow as tf

def clone_with_unique_names(m, suffix="_gc"):
    def clone_fn(layer):
        cfg = layer.get_config()
        if "name" in cfg:
            cfg["name"] = cfg["name"] + suffix
        return layer.__class__.from_config(cfg)

    m2 = tf.keras.models.clone_model(m, clone_function=clone_fn)
    m2.set_weights(m.get_weights())
    return m2

# 1) clone with unique names
model_unique = clone_with_unique_names(model, suffix="_gc")

# 2) build a clean functional graph from the cloned model
inp = tf.keras.Input(shape=(224, 224, 3), name="gc_input")
out = model_unique(inp, training=False)
model_gc = tf.keras.Model(inputs=inp, outputs=out, name="model_gc")

# 3) force-call once
_ = model_gc(tf.convert_to_tensor(x), training=False)

print("Grad-CAM-safe model ready.")
print("Input:", model_gc.input_shape, "Output:", model_gc.output_shape)

import tensorflow as tf

def find_last_conv_anywhere(model_):
    last_name = None

    def walk(layer_or_model):
        nonlocal last_name
        if isinstance(layer_or_model, tf.keras.Model):
            for l in layer_or_model.layers:
                walk(l)
        else:
            if isinstance(layer_or_model, tf.keras.layers.Conv2D):
                last_name = layer_or_model.name

    walk(model_)
    return last_name

LAST_CONV_GC = find_last_conv_anywhere(model_gc)
print("Last Conv2D found anywhere in model_gc:", LAST_CONV_GC)

inner = model_gc.get_layer("sequential")
print("Inner model type:", type(inner).__name__)
print("Inner layers (last 10):")
for layer in inner.layers[-10:]:
    print("-", layer.name, type(layer).__name__)

# Confirm our conv layer is inside
print("\nHas conv2d_2_gc inside inner?", any(l.name == "conv2d_2_gc" for l in inner.layers))

import tensorflow as tf
import numpy as np

def build_gradcam_model_from_inner(outer_model, inner_name, target_conv_name, input_shape=(224,224,3)):
    inner = outer_model.get_layer(inner_name)

    inp = tf.keras.Input(shape=input_shape, name="gc_inp2")
    x = inp
    conv_out = None

    # Replay inner layers so conv_out and preds are in the same graph
    for layer in inner.layers:
        x = layer(x)
        if layer.name == target_conv_name:
            conv_out = x

    if conv_out is None:
        raise ValueError(f"Target conv layer {target_conv_name} not found while replaying.")

    preds = x  # final output after last layer
    return tf.keras.Model(inputs=inp, outputs=[conv_out, preds], name="gradcam_model")

gradcam_model = build_gradcam_model_from_inner(
    outer_model=model_gc,
    inner_name="sequential",
    target_conv_name="conv2d_2_gc",
    input_shape=(224,224,3)
)

# sanity call
_ = gradcam_model(tf.convert_to_tensor(x), training=False)
print("GradCAM model built. Outputs:", [t.shape for t in gradcam_model(tf.convert_to_tensor(x), training=False)])

def make_heatmap_from_gradcam_model(img_tensor, gradcam_model):
    with tf.GradientTape() as tape:
        conv_outputs, preds = gradcam_model(img_tensor, training=False)
        loss = preds[:, 0]

    grads = tape.gradient(loss, conv_outputs)
    pooled_grads = tf.reduce_mean(grads, axis=(0,1,2))

    conv_outputs = conv_outputs[0]  # (H,W,C)
    heatmap = tf.reduce_sum(conv_outputs * pooled_grads, axis=-1)

    heatmap = tf.maximum(heatmap, 0)
    heatmap = heatmap / (tf.reduce_max(heatmap) + 1e-8)
    return heatmap.numpy()

heatmap = make_heatmap_from_gradcam_model(tf.convert_to_tensor(x), gradcam_model)
print("Heatmap shape:", heatmap.shape, "min/max:", float(heatmap.min()), float(heatmap.max()))

import cv2
import numpy as np

def save_gradcam_overlay(orig_bgr, heatmap, out_path="/content/gradcam_overlay.png", alpha=0.40):
    h, w = orig_bgr.shape[:2]

    # Resize heatmap to image size
    hm = cv2.resize(heatmap, (w, h))
    hm = np.uint8(255 * hm)

    # Colorize heatmap
    hm_color = cv2.applyColorMap(hm, cv2.COLORMAP_JET)

    # Overlay
    overlay = cv2.addWeighted(orig_bgr, 1 - alpha, hm_color, alpha, 0)

    cv2.imwrite(out_path, overlay)
    return out_path

out_path = save_gradcam_overlay(orig_bgr, heatmap, out_path="/content/gradcam_overlay.png")
print("Saved:", out_path)